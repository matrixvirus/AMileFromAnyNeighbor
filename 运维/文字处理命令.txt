1
	2018年02月24日。
	参考书是Linux Scripting Cookbook,一个印度人写的那本。
1 cat
	合并空行
	$ cat -s FileName
	显示行号
	$ cat -n FileName
2 tr
	合并空行。-s 意思是合并重复的
	$ cat FileName | tr -s '\n'
	
	把大写字母改成小写
	$ cat FileName | tr 'A-Z' 'a-z'

	把空格改成换行
	$ cat FileName | tr ' ' '\n'

	删除数字2或4
	$ cat FileName | tr -d '[24]'

	删除所有数字
	$ cat FilName | tr -d '[:digit:]'
	[:digit:] 指数字，
	
	全部[::]语法：
	[:alnum:]	字母和数字
	[:alpha:]	字母
	[:blank:]	横向空白字符
	[:cntrl:]	按制字符
	[:digit:]	数字
	[:graph:]	可打印字符，不包括空格
	[:lower:]	小写字母
	[:print:]	可打印字符，包括空格
	[:punct:]	标点
	[:space:]	横向和竖向空白字符
	[:upper:]	大写字母
	[:xdigit:]	十六制数

	删除除数字，空格，和换行以外的字符
	$ cat FileName | tr -d -c '0-0 \n'
	-d和-c组合意思是删除除什么以外
3 sort
	假设有个文件叫UnsortedFile, 内容是规则的几列。
	
	按第1列排序，从小到大，字典方法，比如32会在4前面
	$ sort UnsortedFile

	按第1列，人类可读，从大到小排序
	$ sort -r -h UnsortedFile

	按第2列，人类可读，以逗号作为列分隔符排序
	$ sort -h -t ',' -k 2 UnsortedFile

	消灭重复行
	$ sort -u UnsortedFile
4 uniq
	消灭连续重复行
	$ uniq FileName

	显示重复了的行重复了多少次
	$ uniq -c FileName

	只显示重复的行
	$ uniq -d FileName

	-s 每行跳过前面几个字符
	-w 每行只比较几个字符
	
	比如有个文件，叫FileName
	u:01:gnu
	d:04:linux
	u:01:bash
	u:0:back

	$ uniq -s 2 -w 2 FileName
5 comm
	假设两个文件叫A和B，列出A有B没有，B有A没有，A和B都有的行。两个文件必须先排序
	。
	A的内容：
	1
	2
	3
	4

	B的内容：
	2
	3
	5
	6

	则
	$ comm A B
	输出
	1
            2
            3
	4
        5
        6
	左边一列是A有B没有的，中间一列是B有A没有的，右边一列是A和B都有的。	

	只查看A有B没有的
	$ comm A B -2 -3
	-2和-3意思是不显示本应输出的第2,3列

	只查看B有A没有的
	$ comm A B -1 -3

6 diff
6.1 普通模式
	假设有两文件，一个叫悟空，内容是
	1
	2
	3
	4
	一个叫八戒，内容是
	2
	3
	5
	6

	执行
	$ diff 悟空 八戒
	1 1d0
	2 < 1
	3 4c3,4
	4 < 4
	5 ---
	6 > 5
	7 > 6

	第1行 1d0 意思是悟空的第1行在八戒里删除了
	第2行 < 1 意思是悟空的内容是1的那一行大八戒里删除了，< 是删除
	第3行 4c3,4 意思是悟空的第4行与八戒的第3,4行不同
	第4行 < 4 意思是悟空的第4行在八戒里不见了
	第5行 --- 意思是下面要讲八戒的变化了
	第6行 > 5 意思是八戒的内容为5的那一行是悟空里没有的
	第7行 > 6 意思是八戒的内容为6的那一行是悟空里没有的
6.2 统一模式
	 $ diff -u 悟空 八戒
	1 --- kk1 2018-02-25 04:00:06.628049248 -0500
	2 +++ kk2 2018-02-25 04:00:22.223032479 -0500
	3 @@ -1,4 +1,4 @@
	4 -1
	5  2
	6  3
	7 -4
	8 +5
	9 +6

	第1行 ---开头的是悟空的信息
	第2行 +++开头的是八戒的信息
	第3行 -1 前面的减号指第一个文件，+1前面的加号指第二个文件，第一个文件的1到
		  4行变成了第2个文件的一到4行
	第4行 -1 悟空的内容为1 的那一行在八戒里不见了
	第5行 2 悟空的内容为2的那一行还在八戒里
	第6行 3 悟空的内容为3的那一行还在八戒里
	第7行 -4 悟空的内容为4的那一行在八戒里不见了
	第8行 +5 八戒的内容为5的那一行是悟空里没有的
	第9行 +6 八戒的内容为6的那一行是悟空里没有的

	可以看出悟空是怎么变成八戒的：
	删除第1行
	第2行不变
	第3行不变
	删除第4行
	加一行内容为5
	加一行内容为6
6.3 语境模式
	$ diff -c 悟空 八戒
	*** kk1 2018-02-25 04:00:06.628049248 -0500
	--- kk2 2018-02-25 04:00:22.223032479 -0500
	***************
	1 *** 1,4 ****
	2 - 1
	3   2
	4   3
	5 ! 4
	6 --- 1,4 ----
	7  2
	8  3
	9 ! 5
	A ! 6

	第1行 意思是悟空的1到4行
	第2行 -1 悟空的第1行，内容为1的那行在八戒里不见了
	第3行和第4行 悟空的第2行，内容为2,第3行，内容为3,在八戒里还在
	第5行 ! 4 悟空的第4行，内容为4,在八戒里内容有变化
	第6行 八戒的1到4行
	第9行 八戒的内容为5的那一行的悟空的同一行内容不同

6.4 两列模式
	$ diff -y 悟空 八戒
	1                                                             <
	2                                                               2
	3                                                               3
	4                                                             | 5
	                                                              > 6
	意思依次是：
	删除第1行
	第2行不变
	第3行不变
	第4行的4变成5
	加一行内容为6

6.5 比较两个目
	假如有两个目录，一个叫悟空，一个叫八戒
	$ diff -r 悟空 八戒
	会列出悟空有八戒没有和八戒有悟空没有的文件。

7 grep
	在目前目录里找内容有abc开头的文件
	$ grep -E '^abc' . -r
	
	显示被找到的文件的那一行的上面3行加下面4行
	$ grep -E '^abc'' . -r -B 3 -A 4

	只匹配完整词
	只匹配rm,象rmdir则不会匹配
	$ grep -w rm
8 cut
	一个文件叫鲁迅。
	以空格为分隔，显示鲁迅的第1,2列
	$ cut -d ' ' -f 1,2 鲁迅
	以逗号为分隔，显示除1,2列以外的所有列
	$ cut -d ',' -f 1,2 --complement 鲁迅

	显示第1到5列字符，不存在分隔符
	$ cut -c1-5 鲁迅
9 sed
	一个文件叫鲁迅
	把结尾是大闹天宫的换成别拦我
	$ sed 's/大闹天宫$/别拦我/g' 鲁迅
	那个g,意思是一行中所有的匹配	

	保存修改，加一个参数-i
	$ sed -i 's/大闹天宫$/别拦我/g' 鲁迅

	不一定要用/，还可以用:,|等
	$ sed 's:大闹天宫$:别拦我:g' 鲁迅
	$ sed 's|大闹天宫$|别拦我|g' 鲁迅

	如果分隔符在匹配模式里面，要加\
	$ sed 's/\//\/\//g' 鲁迅

	删除空行
	$ sed '/^$/d' 鲁迅

	正则式不会的话请另专门学习。
10 awk
	形式：
	$ awk 'BEGIN{} {} END{}' 鲁迅

	显示第一行。$0是一整行的意思
	$ awk '{print $0}' 鲁迅
	或
	$ awk '{printf $0"\n"}' 鲁迅

	显示行号，NR是行号，是awk内的一个变量
	$ awk '{print NR,$0}' 鲁迅
	或
	$ awk '{printf "%d %s\n",NR,$0}' 鲁迅
	或，在BEGIN部分，定义一个变量叫i，初值是1，每处理1行，i加1
	$ awk 'BEGIN{i=1}{printf "%d %s\n", i,$0; i++}' 鲁迅

	显示一共有多少行。输出最后一个行号，就是总行数
	$ awk 'END{print NR}' 鲁迅

	以逗号作分隔符，显示第1,3列。FS是awk内一个变量，表示分隔符
	$ awk 'BEGIN{FS=","}{printf "%s,%s\n",$1,$3}' 鲁迅

	只显示第5行
	$ awk '{if(NR == 5) {printf "%s\n",$0}}' 鲁迅

	如果第1列数据是数字，则显示这一行。要用正则，if里面的~号表示用正则
	$ awk '{if($1 ~ "[0-9]*") {printf "%s\n", $0}}' 鲁迅

	每行前面加4个空格。这里要演示for的用法
	$ awk '{for (i=0;i<4;i++) printf " "; printf "%s\n",$0}' 鲁迅

	在awk里使用系统谢儿的变量，假设系统谢儿有个变量叫ohayo
	$ awk -v ohayo=$ohayo '{print ohayo}' 鲁迅

	以默认的空格为分隔符，显示每行有多少列数据
	$ awk '{printf "%d\n", NF}' 鲁迅

	显示每行有多少列字符
	$ awk '{printf "%d\n", length($0)}' 鲁迅

	演示一下数组的用法
	$ awk '{a[NR]=1}END{for (x in a){print a[x]}}' 鲁迅

11 paste
	把多个文件按列拼接
	假设file1的内容是
	1
	2
	3
	file2的内容是
	a
	b
	c

	$ paste file1 file2
	1       a
	2       b
	3       c

